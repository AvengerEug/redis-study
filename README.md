# Redis

## 一、缓存穿透
* 按照我们传统的缓存逻辑，第一次查缓存，缓存不存在则查db。db返回后再同步至缓存。
  这样就会出现缓存穿透的问题，假设用户或者网站攻击者传了一个db和缓存中都不存在的key，此时就会
  缓存和db一块查。最终还是以`无记录`返回。这样的结果就是缓存毫无作用。缓存的qps还
  是稳稳的比db高。若请求量大时，db肯定会先挂。
  
* 解决方案

  |        解决方案        |                          存在的问题                          | 备注 |
  | :--------------------: | :----------------------------------------------------------: | :--: |
  | 缓存空对象 +  超时时间 | 若攻击者使用脚本，循环使用不存在的key进行请求，此时还是每个key都要走一下db |  无  |
  |     使用布隆过滤器     | 具有容错率，有可能会将不存在的key误认为存在，解决此问题也蛮  |      |

  **布隆过滤器**:

    ```txt
  布隆过滤器是一个很长的二进制向量和一些列随机映射函数。它可以检索一个元素是否在一个集合中。优点是空间效率和查询时间远远超过了一般的算法，缺点是存在误判率。
  要想了解这句话，先看下图:
    ```

  ![布隆过滤器原理](https://github.com/AvengerEug/redis-study/blob/develop/布隆过滤器原理.png)

  大致的意思就是: 在一个二进制向量中，我们把一些数据放入至布隆过滤器中。在放入的过程中，每个key会执行N个hash函数，然后将hash之后返回的值对应的槽位上标志为1(eg: hash后的值为10，则在第十个槽上表示为1)。这样，一个key可能在二进制向量中有N个标识。所以当我们要校验，一个key是否在布隆过滤器中时，我们可以把key按照同样的逻辑，进行N个hash，然后校验下N个hash后的值对应的槽是否为1，如果都为1，我们则认为它`可能存在`。如果存在有0，那么它一定不存在。这里说明下，为什么都为1的情况下只是可能存在。`因为hash具有概率性，也就是说不同的key执行hash后有可能返回的值是一样的，这样就发生了hash碰撞。所以二进制向量中某个位置为1，有可能是多个key都会使用上它`

## 二、缓存雪崩

* **同一时间的大面积key失效，导致所有请求都请求到了db**。这时数据库挂了，整个应用肯定都没法工作了呀。
  临时应急方案可以对方法做降级处理，不让它走这个方法

* 当然，我们要从根源解决问题:

  ```txt
  因为雪崩是一些常用的key在某个时间段同时失效，导致请求绕过缓存打向DB。
  所以我们可以为所有的key都随机添加一个失效时间，这样的话，每个key对应
  的失效时间都不同，就不会导致这个问题啦
  setRedis（Key，value，time + Math.random() * 10000）；
  设计随机的过期时间可能也会出现雪崩的场景，这也是有概率发生的。
  最好的就是可以将热点key设置成永远不过期，运维可以选择在用户使用少的情况下，
  在后台对某些业务逻辑做操作, 来触发更新缓存的操作
  ```

## 三、缓存击穿

* 缓存击穿和缓存雪崩类似，但又有点不同。缓存雪崩是大面积key失效而把请求打入db。而缓存击穿是因为某一个key失效. 

* 解决方案:

  ```txt
  同上，缓存击穿和可以和雪崩一样设置key永远不过期，
  再手动去触发更新缓存的操作
  ```

  