# Redis

## 一、缓存穿透
* 按照我们传统的缓存逻辑，第一次查缓存，缓存不存在则查db。db返回后再同步至缓存。
  这样就会出现缓存穿透的问题，假设用户或者网站攻击者传了一个db和缓存中都不存在的key，此时就会
  缓存和db一块查。最终还是以`无记录`返回。这样的结果就是缓存毫无作用。缓存的qps还
  是稳稳的比db高。若请求量大时，db肯定会先挂。
  
* 解决方案

  |        解决方案        |                          存在的问题                          | 备注 |
  | :--------------------: | :----------------------------------------------------------: | :--: |
  | 缓存空对象 +  超时时间 | 若攻击者使用脚本，循环使用不存在的key进行请求，此时还是每个key都要走一下db |  无  |
  |     使用布隆过滤器     | 具有容错率，有可能会将不存在的key误认为存在，解决此问题也蛮  |      |

  **布隆过滤器**:

    ```txt
  布隆过滤器是一个很长的二进制向量和一些列随机映射函数。它可以检索一个元素是否在一个集合中。优点是空间效率和查询时间远远超过了一般的算法，缺点是存在误判率。
  要想了解这句话，先看下图:
    ```

  ![布隆过滤器原理](https://github.com/AvengerEug/redis-study/blob/develop/布隆过滤器原理.png)

  大致的意思就是: 在一个二进制向量中，我们把一些数据放入至布隆过滤器中。在放入的过程中，每个key会执行N个hash函数，然后将hash之后返回的值对应的槽位上标志为1(eg: hash后的值为10，则在第十个槽上表示为1)。这样，一个key可能在二进制向量中有N个标识。所以当我们要校验，一个key是否在布隆过滤器中时，我们可以把key按照同样的逻辑，进行N个hash，然后校验下N个hash后的值对应的槽是否为1，如果都为1，我们则认为它`可能存在`。如果存在有0，那么它一定不存在。这里说明下，为什么都为1的情况下只是可能存在。`因为hash具有概率性，也就是说不同的key执行hash后有可能返回的值是一样的，这样就发生了hash碰撞。所以二进制向量中某个位置为1，有可能是多个key都会使用上它`

## 二、缓存雪崩

* **同一时间的大面积key失效，导致所有请求都请求到了db**。这时数据库挂了，整个应用肯定都没法工作了呀。
  临时应急方案可以对方法做降级处理，不让它走这个方法

* 当然，我们要从根源解决问题:

  ```txt
  因为雪崩是一些常用的key在某个时间段同时失效，导致请求绕过缓存打向DB。
  所以我们可以为所有的key都随机添加一个失效时间，这样的话，每个key对应
  的失效时间都不同，就不会导致这个问题啦
  setRedis（Key，value，time + Math.random() * 10000）；
  设计随机的过期时间可能也会出现雪崩的场景，这也是有概率发生的。
  最好的就是可以将热点key设置成永远不过期，运维可以选择在用户使用少的情况下，
  在后台对某些业务逻辑做操作, 来触发更新缓存的操作
  ```

## 三、缓存击穿

* 缓存击穿和缓存雪崩类似，但又有点不同。缓存雪崩是大面积key失效而把请求打入db。而缓存击穿是因为某一个key失效. 

* 解决方案:

  ```txt
  同上，缓存击穿和可以和雪崩一样设置key永远不过期，
  再手动去触发更新缓存的操作
  ```



## 四、分布式锁

* 使用策略者设计模式体现了分布式锁的一步步优化。

* 使用redis作为分布式锁的基础: `setnx (set if not exist)`，它是一个原子性操作，集合redis单线程的特性。一次只能有一个人能set成功

  * 第一种：使用**setnx** + **exist** + **del**指令   ===>   `exist + del 两个操作非原子性`

    ```markdown
    大致的流程为: 
      先setnx，若返回1(setnx命令返回的是1)则表示加锁成功。然后去处理正常逻辑，处理完成后则校验key(exist指令)是否存在，若存在则解锁(del指令)。
      
    按照上面的正常逻辑好像没有一点问题，但是我们细分一下:
    setnx是保证了互斥性，保证只有一个人能set成功(获取到锁) --> 这没有问题
    
    exist + del 判断key存在则删除 ---> `这里有问题！`
    为什么呢？首先exist和del是两个指令，对于redis单线程而言，完全有可能在exist和del指令执行之间执行其他指令。可能你会说，没关系呀，反正我就是要删除他，就算中间穿插的命令为增删改，我最后还是可以删除呀。当然，这无可厚非，**但是如果此时中间执行的操作是把其他锁给删掉了呢？那不是会乱套？或者说在中间准备执行del指令时，应用程序挂了，那这把锁不就变成死锁了嘛** 所以我们要保证，exist + del作为原子性的操作来执行。对于redis而言，没有一个命令具备这样的功能，所以此时我们可以使用lua脚本来保证他们的原子性操作;
    
    所以这样就引出了下面第二种的实现方式
    ```

  * 第二种: 使用**setnx** + **lua脚本删除锁**   ====>  `解锁步骤依赖与代码，可能造成死锁`

    ```markdown
    此种方式与第一种相比, 唯一的不同就是在删除锁的那一步，在此种方式中保证了`exist + del`操作的原子性。好像，这么一整套下来没什么问题。但，仔细一想，锁的删除是依赖与一段代码来执行的。**假设，在获取锁并执行业务逻辑的过程中，项目抛运行时异常了或者直接挂了...**`没错，它又变成死锁了，这把锁永远不会被释放了`。于是，针对此种情况，出现了如下第三种设计方案
    ```

  * 第三种: 使用**setnx** + **expire** + **lua脚本删除锁**  ====>  `setnx + expire操作非原子性`

    ```markdown
    此种方式在第二种的基础上，完善了加锁流程，即我加完锁后给锁设置一个过期时间，这样就算应用程序挂了、业务逻辑抛异常等等任何原因导致不会执行lua脚本释放锁的代码。都能保证不会造成死锁。 但是，这又出现了第一种的问题了, 两个操作不是原子性操作。可能聪明的你又会说，可以使用lua脚本呀。不巧的是，redis支持`setnx + expire`原子性操作的指令。于是引出了下面第四种版本。
    ```

  * 第四种: 使用**set key value nx ex seconds** + **lua脚本删除锁**

    ```markdown
    使用此种方式好像已经无懈可击了。就算程序挂了，我有自动过期时间，完全不怕死锁。好像的确已经无懈可击了。哦，不对。你的锁有过期时间，`假设我们的业务逻辑消耗时间比过期时间还长怎么办？此时我们的业务还在执行，但是锁已经没有了，其他的请求又可以拿到锁进行业务逻辑了。此时锁不就失去了它的互斥性了嘛？并且锁的key都是一样的，所以在这种情况下前一个拿到锁的实例还会执行删除锁的逻辑，此时完全有可能删除其他实例获取的锁`。
    于是，引出了下面的最终版本:
    ```

  * 最终版本: 使用**set key value nx ex seconds** + **lua脚本删除锁** + **随机value**

    ```
    在添加key时，我们可以添加一个唯一的value(eg: uuid). 我们可以根据这个value来决定能不能删除这个锁，因为我set锁的时候我能知道set进去的value是怎样的，最后再确认下key对应的value是不是我set的value，如果是则允许删除。否则则删除不了，这样就避免了其他人删除了我的锁的情况
    ```

* **综上所述，redis实现分布式锁会存在`死锁`，`非原子性`，`防止他人删除自己锁`的问题，对应的解决策略就是`设置过期时间`, `使用lua脚本或redis中自带的原子性命令`, `添加唯一value，根据value删除锁`**

* **具体参考[传送门](https://github.com/AvengerEug/redis-study/tree/develop/redis-basic/src/main/java/com/eugene/sumarry/redis/distributedlock)**

* **同时记录下在使用redis实现分布式锁遇到的问题**:

  ```java
  1. 遇到的第一个问题: 使用多线程操作同一个jedis对象，报了很多奇怪的错:
   *   redis.clients.jedis.exceptions.JedisConnectionException: Unexpected end of stream.
   *   ERR Protocol error: invalid multibulk length
   *   read time out
   *   最终解决方案是每一个线程操作redis时，都从redisPool中去获取jedis对象。
   *   并使用ThreadLocal的特性保证每个jedis都是从redisPool中去获取jedis对象。
  2. 需要设置JedisPool的配置设置最大等待时间，因为锁会自旋，所以会出现一些超时的情况:
     具体配置如下:
       static {
           // 最大链接，-1表示无限制
           jedisPoolConfig.setMaxTotal(-1);
           // 最大等待时间, -1表示无限制
           jedisPoolConfig.setMaxWaitMillis(-1);
       }
  
       private static final JedisPool jedisPool = new JedisPool(jedisPoolConfig,"127.0.0.1", 6379);
  
  ```

  



